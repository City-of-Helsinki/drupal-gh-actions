on:
  workflow_call:
    inputs:
      compose_files:
        description: 'Compose files'
        default: 'compose.yaml:compose.ci.yaml'
        required: false
        type: string
      php_version:
        description: 'Used PHP version'
        required: true
        type: string
      # Composer dev dependencies are never parsed. Make sure to include
      # all necessary dev dependencies here.
      composer_dev_dependencies:
        description: 'Extra composer dev dependencies'
        required: false
        default: ''
        type: string
      phpcs_args:
        description: 'Used phpcs arguments. These are emitted if phpcs.xml file exists.'
        required: false
        type: string
        default: '--standard=Drupal --extensions=php,module,install,theme,inc'
    secrets:
      sonarcloud_token:
        required: false
      # This is used by drupal/helfi_azure_fs module.
      flysystem_azure_connection_string:
        required: false
env:
  SYMFONY_DEPRECATIONS_HELPER: disabled
  COMPOSER_DISCARD_CHANGES: true
  COMPOSER_MIRROR_PATH_REPOS: 1
  CODECOV_TOKEN: ${{ secrets.codecov_token }}
  SONARCLOUD_TOKEN: ${{ secrets.sonarcloud_token }}
  FLYSYSTEM_AZURE_CONNECTION_STRING: ${{ secrets.flysystem_azure_connection_string }}
jobs:
  tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          repository: druidfi/stonehenge

      - name: Install and start Stonehenge
        run: make up

      - name: Clone platform
        run: |
          git clone --branch UHF-11502 --depth=1 https://github.com/City-of-Helsinki/drupal-helfi-platform.git ./drupal
          rm -rf ./drupal/.git

      - uses: actions/checkout@v5
        with:
          path: 'drupal/module'

      - name: Parse $MODULE_NAME from composer.json
        working-directory: drupal/module
        run: echo "MODULE_NAME=$(cat composer.json | jq -r .name | awk -F/ '{print $NF}')" >> $GITHUB_ENV


      - name: Setup Docker compose environment variables
        working-directory: drupal
        run: |
          # Read existing compose profiles from .env file
          source .env

          # Make sure testing is always included in compose profiles.
          if [ ! -n "$COMPOSE_PROFILES" ]; then
            COMPOSE_PROFILES=testing
          else
            COMPOSE_PROFILES=$COMPOSE_PROFILES,testing
          fi
          echo "COMPOSE_FILE=${{ inputs.compose_files }}" >> $GITHUB_ENV
          echo "COMPOSE_PROFILES=$COMPOSE_PROFILES" >> $GITHUB_ENV

      - name: Start compose project
        working-directory: drupal
        run: docker compose up -d --wait

      - name: Install required composer dependencies
        working-directory: drupal
        run: |
          # We use mglaman/composer-drupal-lenient to patch modules that are
          # not compatible with the latest core version.
          # The package must be installed globally because otherwise it
          # doesn't work.
          # @see https://github.com/mglaman/composer-drupal-lenient?tab=readme-ov-file#support-when-composerlock-removed
          docker compose exec app bash -c "composer global config --no-plugins allow-plugins.mglaman/composer-drupal-lenient true"
          docker compose exec app bash -c "composer global require mglaman/composer-drupal-lenient"
          docker compose exec app bash -c "composer config repositories.5 path module"
          docker compose exec app bash -c "composer require drupal/$MODULE_NAME ${{ inputs.composer_dev_dependencies }} -W"
          # We use COMPOSER_MIRROR_PATH_REPOS=1 to mirror local repository
          # instead of symlinking it to prevent code coverage issues with
          # phpunit. Copy .git folder manually so codecov can generate line by
          # line coverage.
          docker compose exec app bash -c "cp -r module/.git public/modules/contrib/$MODULE_NAME/"

      - name: Run PHPCS
        working-directory: drupal
        run: |
          MODULE_FOLDER=/app/public/modules/contrib/$MODULE_NAME

          if [ ! -f "$MODULE_FOLDER/phpcs.xml" ]; then
            ARGS='${{ inputs.phpcs_args }}'
          else
            # Remove any existing phpcs files and copy module's
            # phpcs file to Drupal root.
            docker compose exec app bash -c "rm -f phpcs.xml.dist"
            docker compose exec app bash -c "cp $MODULE_FOLDER/phpcs.xml ."
          fi
          docker compose exec app php vendor/bin/phpcs $MODULE_FOLDER $ARGS

      - name: Run phpstan
        working-directory: drupal
        run: docker compose exec app php vendor/bin/phpstan analyze -c public/modules/contrib/$MODULE_NAME/phpstan.neon public/modules/contrib/$MODULE_NAME

      - name: Install Drupal
        working-directory: drupal
        run: |
          docker compose exec app bash -c "vendor/bin/drush si -y"
          docker compose exec app bash -c "vendor/bin/drush en $MODULE_NAME"

      - name: Run PHPUnit tests
        working-directory: drupal
        run: |
          docker compose exec app bash -c "mkdir -p /app/results"
          docker compose exec app php vendor/bin/phpunit \
            --bootstrap /app/public/core/tests/bootstrap.php \
            -c /app/public/modules/contrib/$MODULE_NAME/phpunit.xml \
            --coverage-clover=/app/coverage-base.xml \
            --testsuite unit,kernel

      - name: Export coverage.xml
        working-directory: drupal
        run: |
          docker compose exec app bash -c "cat /app/coverage-base.xml" > coverage.xml

      - name: SonarQube Scan
        working-directory: drupal
        if: ${{ env.SONARCLOUD_TOKEN }}
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          SONAR_TOKEN: ${{ secrets.sonarcloud_token }}

      - name: Export logs
        working-directory: drupal
        if: always()
        run: docker compose logs app > results/service.log

      - name: Create an artifact from test report
        working-directory: drupal
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: results
          path: results/
          retention-days: 1
